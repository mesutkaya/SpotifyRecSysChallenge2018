/**
 * # Licensed under the Apache License, Version 2.0 (the "License");
 * # you may not use this file except in compliance with the License.
 * # You may obtain a copy of the License at
 * #
 * #     http://www.apache.org/licenses/LICENSE-2.0
 * #
 * # Unless required by applicable law or agreed to in writing,
 * # software distributed under the License is distributed on an
 * # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * # KIND, either express or implied.  See the License for the
 * # specific language governing permissions and limitations
 * # under the License.
 */
package spotify_challenge;

import com.google.common.collect.Sets;

import es.uam.eps.ir.ranksys.fast.index.FastItemIndex;
import es.uam.eps.ir.ranksys.fast.index.FastUserIndex;
import es.uam.eps.ir.ranksys.fast.index.SimpleFastItemIndex;
import es.uam.eps.ir.ranksys.fast.index.SimpleFastUserIndex;
import es.uam.eps.ir.ranksys.fast.preference.FastPreferenceData;
import es.uam.eps.ir.ranksys.fast.preference.SimpleFastPreferenceData;
import es.uam.eps.ir.ranksys.novdiv.reranking.Reranker;
import org.jooq.lambda.Unchecked;
import org.ranksys.formats.index.ItemsReader;
import org.ranksys.formats.index.UsersReader;
import org.ranksys.formats.parsing.Parser;
import org.ranksys.formats.rec.RecommendationFormat;
import org.ranksys.formats.rec.SimpleRecommendationFormat;
import reranker.*;

import java.io.*;
import java.util.*;
import java.util.function.Supplier;

import static es.uam.eps.ir.ranksys.core.util.FastStringSplitter.split;
import static org.ranksys.formats.parsing.Parsers.lp;
import static org.ranksys.formats.parsing.Parsers.sp;

/**
 * Created by messe on 19/06/18.
 * <p>
 * Re-ranks recommendations generated by Matrix Factorization algorithm (It can be any recommender as well) by using
 * detected sub-playlists of 8000 non-cold-start playlists in the challenge set!
 * <p>
 * Assuming that MPD and Challenge Set data is preprocessed by python scripts here only change MPD_PATH and run it.
 */
public class SPADReranker<U, I> {
    public static void main(String[] args) throws Exception {
        String MPD_PATH = "/run/media/messe/roziklinux/spotify_challenge/mpd.v1/"; // replace with your path!
        String DATA_PATH = MPD_PATH + "/exp_data/";
        String userPath = DATA_PATH + "/u_index.txt";
        String itemPath = DATA_PATH + "/i_index.txt";
        String trainDataPath = DATA_PATH + "/subprofile_train.csv";

        String recIn = DATA_PATH + "pzt_100_50.0";
        String spFolderName = "ibsp";
        String spPrefix = "sp_ib_KNNJ_";

        String simFilePath = DATA_PATH + "/ibsp/sim_ib_100";

        //String base_file = args[3]; //{"t_pzt_30_1.0"};

        //double[] lambdas = {0.4};
        double[] lambdas = {0.4};
        int cutoff = 500;
        int maxLength = 500;
        int[] K_IB = {30};
        int[] K_DC = {70};

        FastUserIndex<Long> userIndex = SimpleFastUserIndex.load(UsersReader.read(userPath, lp));
        FastItemIndex<Long> itemIndex = SimpleFastItemIndex.load(ItemsReader.read(itemPath, lp));
        RecommendationFormat<Long, Long> format = new SimpleRecommendationFormat<>(lp, lp);


        System.out.println("Re-ranking the file: " + recIn);

        FastPreferenceData<Long, Long> trainData = SimpleFastPreferenceData.load(SpotifyPreferenceReader.
                get().read(trainDataPath, lp, lp), userIndex, itemIndex);


        Map<Long, Map<Long, Boolean>> itemSims = loadItemSims(simFilePath, K_DC[0]);
        String spPath = DATA_PATH + "/" + spFolderName + "/" + spPrefix + Integer.toString(K_IB[0]);
        Map<Long, Map<String, List<Long>>> subProfiles = loadSubProfiles(new FileInputStream(spPath), '\t', lp, lp, sp);
        SPIntentModel<Long, Long, String> intentModel = new SPADIntentModel<Long, Long, String>(trainData, subProfiles, itemSims, itemIndex);
        SPAspectModel<Long, Long, String> aspectModel;
        aspectModel = new SubProfileAspectModel<>(intentModel);
        Map<String, Supplier<Reranker<Long, Long>>> rerankersMap = new HashMap<>();

        for (double lambda : lambdas) {
            String preName = "SpeX_KNNJ";
            rerankersMap.put(preName + "_" + Integer.toString(K_IB[0]) + "_" + Integer.toString(K_DC[0]) + "_" +
                    Double.toString(lambda), () -> {

                return new SPAD<>(aspectModel, lambda, cutoff, true);


            });
        }
        rerankersMap.forEach(Unchecked.biConsumer((name, rerankerSupplier) -> {
            System.out.println("Running " + name);
            String recOut = recIn + "_" + name;
            Reranker<Long, Long> reranker = rerankerSupplier.get();
            try (RecommendationFormat.Writer<Long, Long> writer = format.getWriter(recOut)) {
                format.getReader(recIn).readAll()
                        .map(rec -> reranker.rerankRecommendation(rec, maxLength))
                        .forEach(Unchecked.consumer(writer::write));
            }
        }));
    }

    /**
     * Loads pre-computed item-item similarities from a file.
     *
     * @param filePath item-item similarities file
     * @param k        number of neighbours.
     * @return
     */
    public static Map<Long, Map<Long, Boolean>> loadItemSims(String filePath, int k) {
        Scanner s = null;
        try {
            s = new Scanner(new File(filePath));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        Map<Long, Map<Long, Boolean>> itemSims = new HashMap<>();

        while (s.hasNext()) {
            String line = s.next();

            CharSequence[] tokens = split(line, ',');
            long iidx = lp.parse(tokens[0]);
            Map<Long, Boolean> neighbors = new HashMap<>();
            for (int i = 1; i < Math.min(k + 1, tokens.length); i++) {
                neighbors.put(lp.parse(tokens[i]), true);
            }

            itemSims.put(iidx, neighbors);
        }
        s.close();
        System.out.println("Finished loading item-item similarities!");
        return itemSims;
    }

    /**
     * @param in      InputStream to read the file consisting subprofile candidates for each user
     * @param sep     file separator
     * @param up      U parser
     * @param ip      I parser
     * @param sparser S parser
     * @param <U>     user
     * @param <I>     item
     * @param <S>     subprofile
     * @return
     */
    public static <U, I, S> Map<U, Map<S, List<I>>> loadSubProfiles(InputStream in, Character sep, Parser<U> up, Parser<I> ip, Parser<S> sparser) {
        Map<U, List<Set<I>>> subProfiles = new HashMap<>();
        Map<U, Map<S, List<I>>> finalSubProfiles = new HashMap<>();

        new BufferedReader(new InputStreamReader(in)).lines().forEach(line -> {

            CharSequence[] tokens = split(line, sep);
            if (tokens.length < 3) {
                System.out.println(line);
            }
            U user = up.parse(tokens[0]);
            S s = sparser.parse(tokens[1]);

            Set<I> sp = new HashSet<>();
            if (!(tokens.length == 3 && tokens[2].length() == 0)) {
                for (int index = 2; index < tokens.length; index++) {
                    I spItem = null;
                    try {
                        spItem = ip.parse(tokens[index]);
                    } catch (Exception e) {
                        System.out.println(line);

                        System.out.println(tokens[index]);
                        return;
                    }

                    sp.add(spItem);
                }

                if (subProfiles.containsKey(user)) {
                    subProfiles.get(user).add(sp);
                } else {
                    List<Set<I>> usersps = new ArrayList<>();
                    usersps.add(sp);
                    subProfiles.put(user, usersps);
                }
            }

        });

        // Sort the candiate subprofiles by size and then eliminate the smaller ones if they are subset of the larger.
        subProfiles.forEach((u, l) -> {
            List<Integer> tobeRemoved = new ArrayList<>();
            l.sort(Comparator.comparing(Set::size));
            for (int i = 0; i < l.size() - 1; i++) {
                for (int j = i + 1; j < l.size(); j++) {
                    Set<I> intersection = Sets.intersection(l.get(i), l.get(j));
                    if (intersection.size() == l.get(i).size()) {
                        tobeRemoved.add(i);
                        break;
                    }
                }
            }


            Collections.reverse(tobeRemoved);
            for (int index : tobeRemoved) {
                l.remove(index);
            }

            final int[] counter = {0};
            l.stream().forEach(set -> {
                if (finalSubProfiles.containsKey(u)) {
                    finalSubProfiles.get(u).put(sparser.parse("S" + Integer.toString(counter[0])), new ArrayList<>(set));
                } else {
                    Map<S, List<I>> temp = new HashMap<>();
                    temp.put(sparser.parse("S" + Integer.toString(counter[0])), new ArrayList<>(set));
                    finalSubProfiles.put(u, temp);
                }
                counter[0]++;
            });
        });

        System.out.println("Finished extracting the subprofiles from file!");

        return finalSubProfiles;
    }
}
