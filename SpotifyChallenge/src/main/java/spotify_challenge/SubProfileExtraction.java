/**
 * # Licensed under the Apache License, Version 2.0 (the "License");
 * # you may not use this file except in compliance with the License.
 * # You may obtain a copy of the License at
 * #
 * #     http://www.apache.org/licenses/LICENSE-2.0
 * #
 * # Unless required by applicable law or agreed to in writing,
 * # software distributed under the License is distributed on an
 * # "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * # KIND, either express or implied.  See the License for the
 * # specific language governing permissions and limitations
 * # under the License.
 */
package spotify_challenge;

import es.uam.eps.ir.ranksys.fast.index.FastItemIndex;
import es.uam.eps.ir.ranksys.fast.index.FastUserIndex;
import es.uam.eps.ir.ranksys.fast.index.SimpleFastItemIndex;
import es.uam.eps.ir.ranksys.fast.index.SimpleFastUserIndex;
import es.uam.eps.ir.ranksys.fast.preference.FastPreferenceData;
import es.uam.eps.ir.ranksys.fast.preference.IdxPref;
import es.uam.eps.ir.ranksys.fast.preference.SimpleFastPreferenceData;
import org.ranksys.formats.index.ItemsReader;
import org.ranksys.formats.index.UsersReader;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static es.uam.eps.ir.ranksys.core.util.FastStringSplitter.split;
import static org.ranksys.formats.parsing.Parsers.lp;

/**
 * Created by Mesut Kaya on 16/06/18.
 * <p>
 * Assuming that MPD and Challenge Set data is preprocessed by python scripts here only change MPD_PATH and run it.
 * <p>
 * For 8000 non-cold-start playlists in the challenge set, we split them into sub-playlists.
 * <p>
 * We have published the idea
 * of using subprofiles in our paper: "Mesut Kaya & Derek Bridge, Accurate and Diverse Recommendations Using Item-Based SubProfiles,
 * Florida Artificial Intelligence Research Society Conference, 2018."
 * <p>
 * For the paper: https://aaai.org/ocs/index.php/FLAIRS/FLAIRS18/paper/view/17600
 * <p>
 * The subprofile extraction algorithm provided here is a simpler and more efficient way compared with our publication.
 * <p>
 * For Spotify challenge, the idea is that in the playlists there are sub-interests or sub-tastes of the users.
 * We use detected sub-playlists as aspects to diversify the recommendations generated by Matrix Factorization algorithm
 */
public class SubProfileExtraction {
    public static void main(String[] args) throws IOException {
        String MPD_PATH = "/run/media/messe/roziklinux/spotify_challenge/mpd.v1/"; // replace with your path!
        String DATA_PATH = MPD_PATH + "/exp_data/";
        String userPath = DATA_PATH + "/u_index.txt";
        String itemPath = DATA_PATH + "/i_index.txt";

        String trainDataPath = DATA_PATH + "subprofile_train.csv";
        String challengeUsersPath = DATA_PATH + "challenge_users.csv";

        int[] factors = {30};
        // Threshold for the liked items, in our case the data is implicit so all tracks are liked.
        double threshold = 1.0;
        String SP_PREFIX = "sp_ib_KNNJ_";
        String subProfileFilePath = "ibsp/";

        Set<Long> targetUsers = loadTestUsers(challengeUsersPath);

        FastUserIndex<Long> userIndex = SimpleFastUserIndex.load(UsersReader.read(userPath, lp));
        FastItemIndex<Long> itemIndex = SimpleFastItemIndex.load(ItemsReader.read(itemPath, lp));


        FastPreferenceData<Long, Long> trainData = SimpleFastPreferenceData.load(SpotifyPreferenceReader.get().read(trainDataPath, lp, lp), userIndex, itemIndex);


        // user-based nearest neighbors subprofile version
        for (int k : factors) {
            String spPath = DATA_PATH + "/" + subProfileFilePath + "/";
            Path path = Paths.get(spPath);
            if (Files.notExists(path)) {
                Files.createDirectory(path);
            }
            System.out.println(spPath + "\t" + Integer.toString(k));

            String simFilePath = DATA_PATH + "/ibsp/sim_ib_100";
            Map<Integer, List<Integer>> itemSims = loadItemSims(simFilePath, itemIndex, k);


            final int[] counter = {0};
            Path spFilePath = Paths.get((spPath + SP_PREFIX + Integer.toString(k)));

            try (BufferedWriter writer = Files.newBufferedWriter(spFilePath)) {

                targetUsers.forEach(uid -> {
                    int uidx = userIndex.user2uidx(uid);
                    System.out.println(counter[0]++);
                    Map<Integer, List<Integer>> sps = new HashMap<>();
                    List<Integer> likedItemIndexes = getUserLikes(trainData.getUidxPreferences(uidx), threshold);
                    for (int iidx : likedItemIndexes) {
                        List<Integer> sp = new ArrayList<>();
                        sp.add(iidx); // This line is to make sure liked item is also in the same subprofile!
                        for (int jidx : likedItemIndexes) {
                            if (iidx == jidx) continue;
                            boolean add = false;
                            if (itemSims.get(jidx).contains(iidx)) add = true;
                            if (add) {
                                sp.add(jidx);
                            }
                        }
                        sps.put(iidx, sp);
                    }

                    sps.forEach((iidx, sp) -> {
                        Long iid = itemIndex.iidx2item(iidx);
                        String spString = "";
                        for (int jidx : sp) {
                            Long jid = itemIndex.iidx2item(jidx);
                            if (sp.indexOf(jidx) == sp.size() - 1)
                                spString += Long.toString(jid);
                            else
                                spString += Long.toString(jid) + "\t";
                        }
                        try {
                            writer.write(Long.toString(uid) + "\t" + Long.toString(iid) + "\t" + spString);
                            writer.newLine();
                            writer.flush();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    });
                });
            }

        }

    }

    /**
     * return list of indexes of liked items of a user
     *
     * @param uPref
     * @param threshold
     * @return
     */
    public static List<Integer> getUserLikes(Stream<? extends IdxPref> uPref, double threshold) {
        Set<Integer> result = new HashSet<>();
        uPref.forEach(iv -> {
            if (iv.v2 >= threshold) result.add(iv.v1);
        });
        return result.stream().collect(Collectors.toList());
    }


    public static Set<Long> loadTestUsers(String filePath) {
        Scanner s = null;
        try {
            s = new Scanner(new File(filePath));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        Set<Long> list = new HashSet<>();
        while (s.hasNext()) {
            list.add(Long.parseLong(s.next()));
        }
        s.close();
        return list;
    }

    public static Map<Integer, List<Integer>> loadItemSims(String filePath, FastItemIndex<Long> itemIndex, int k) {
        Scanner s = null;
        try {
            s = new Scanner(new File(filePath));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        Map<Integer, List<Integer>> itemSims = new HashMap<>();
        int counter = 0;
        while (s.hasNext()) {
            String line = s.next();
            CharSequence[] tokens = split(line, ',');
            int iidx = itemIndex.item2iidx(lp.parse(tokens[0]));
            List<Integer> neighbors = new ArrayList<>();
            for (int i = 1; i < Math.min(k + 1, tokens.length); i++) {
                neighbors.add(itemIndex.item2iidx(lp.parse(tokens[i])));
            }

            itemSims.put(iidx, neighbors);
        }
        s.close();
        System.out.println("Finished loading item-item similarities!");
        return itemSims;
    }
}
