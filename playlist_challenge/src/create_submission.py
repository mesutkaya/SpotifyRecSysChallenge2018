# -*- coding: utf-8 -*-

#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
import json
import os
import pickle
from collections import defaultdict

import settings
import util


def load_pop_recommendations(pop_file_path, inv_item_mappings):
    """
    Load popularity recommendations generated by RankSys (Java 1.8). For some cold start scenario playlists,
    if there are not enough items to recommend (<500), we complete 500 recommendations by using most popular tracks!
    :param pop_file_path:
    :param inv_item_mappings:
    :return:
    """
    pop_file = open(pop_file_path, 'r')
    pop_recs = []
    for line in pop_file:
        line = line.strip().split('\t')
        rec = int(line[1])
        pop_recs.append(inv_item_mappings[rec])
    pop_file.close()
    return pop_recs


def load_title_popularity_recommendations(rec_file_path):
    """

    :param rec_file_path:
    :return:
    """
    title_pop_recs = defaultdict(list)
    rec_file = open(rec_file_path, 'r')
    for line in rec_file:
        line = line.strip().split(',')
        title = line[0]
        recs = []
        for i in range(1, len(line)):
            recs.append(line[i])
        title_pop_recs[title] = recs
    rec_file.close()
    return title_pop_recs


def get_total_cold_start_recs(title, title_pop_recs, pop_recs):
    """
    Based on title popularity recommender for the cold start scenario!
    This method is called for playlists with title info only!
    :param title:
    :param title_pop_recs:
    :param pop_recs:
    :return:
    """
    t_recs = title_pop_recs[title]
    temp = [r for r in t_recs]
    if len(temp) < 500:
        for pop_rec in pop_recs:
            if pop_rec not in temp:
                temp.append(pop_rec)
            if len(temp) == 500:
                break
    else:
        return temp[:500]
    return temp


def get_one_song_cold_start_recs(title, title_pop_recs, pop_recs, trackID):
    """
        Based on title popularity recommender for the cold start scenario!
        This method is called for playlists with title info and first song!!
        :param title:
        :param title_pop_recs:
        :param pop_recs:
        :return:
        """
    t_recs = title_pop_recs[title]
    print(len(t_recs), title)
    temp2 = [r for r in t_recs if not trackID == r]
    if len(temp2) < 500:
        for pop_rec in pop_recs:
            if pop_rec not in temp2 and trackID != pop_rec:
                temp2.append(pop_rec)
            if len(temp2) == 500:
                break
    else:
        return temp2[:500]
    return temp2


def load_all_recs(rec_file_path):
    """
    Loads all recommendations from matrix factorization + SPAD without any mapping change!
    These are generated recommendations for playlist in the challenge set except the cold start playlists (no song and first song only)
    :param rec_file_path:
    :return:
    """
    rec_file = open(rec_file_path, 'r')
    recs = defaultdict(list)
    for line in rec_file:
        line = line.strip().split('\t')
        user = int(line[0])
        item = int(line[1])
        val = float(line[2])
        recs[user].append((item, val))
    rec_file.close()
    return recs


def get_recommendations_for_playlist(all_recs, pID, inv_item_mappings):
    u_recs = all_recs[pID]
    result = [inv_item_mappings[item[0]] for item in u_recs]
    return result


def main():
    DATA_PATH = os.path.join(settings.MPD_PATH, settings.EXP_DIR_NAME)
    pop_file_path = os.path.join(DATA_PATH, 'pop')
    rec_file_path = os.path.join(DATA_PATH, 'pzt_100_50.0_SpeX_KNNJ_30_70_0.4')
    sub_file_path = os.path.join(DATA_PATH, 'sample_submission.csv')
    submission_file = open(sub_file_path, 'w')
    # submission_file.write("team_info,main,teamrozik,115220587@umail.ucc.ie" + '\n')
    submission_file.write("team_info,creative,teamrozik,115220587@umail.ucc.ie" + '\n')

    CHALLENGE_DATA_PATH = settings.CHALLENGE_DATA_PATH

    title_pop_rec_path = os.path.join(DATA_PATH, 'title_popularity_recs.csv')
    title_one_song_pop_rec_path = os.path.join(DATA_PATH, 'title_one_song_popularity_recs.csv')

    print("Loading user and item mappings!")
    user_mapping_path = os.path.join(DATA_PATH, "user_mappings.tsv")
    user_mapping = pickle.load(open(user_mapping_path, 'rb'))

    item_mapping_path = os.path.join(DATA_PATH, "item_mappings.tsv")
    item_mapping = pickle.load(open(item_mapping_path, 'rb'))
    inverse_item_mapping = dict((v, k) for (k, v) in item_mapping.iteritems())

    print("Finished loading user and item mappings!")

    pop_recs = load_pop_recommendations(pop_file_path, inverse_item_mapping)
    print("Finished Loading popularity recommendations!")
    # recs = load_recommendations(rec_file_path, inverse_item_mapping, inverse_user_mapping, c_users)
    all_recs = load_all_recs(rec_file_path)
    print("Finished Loading recommendations for non cold-start playlists!")

    # title_recs = generate_title_recommendations(title_mapping, all_recs, pop_recs, inverse_item_mapping)
    # print("Finished generating title recommendations!")

    title_pop_recs = load_title_popularity_recommendations(title_pop_rec_path)
    print("Finished loading title populariy recommendations for cold start playlists!")
    title_one_song_pop_recs = load_title_popularity_recommendations(title_one_song_pop_rec_path)
    print("Finished loading title populariy recommendations for one track only!")

    # Read challenge set!
    f = open(os.path.join(CHALLENGE_DATA_PATH, "challenge_set.json"))
    js = f.read()
    challenge_set = json.loads(js)
    f.close()

    # First write the popularity recs
    for playlist in challenge_set['playlists']:
        pID = int(playlist['pid'])
        num_tracks = playlist['num_samples']

        if num_tracks > 1:
            temp = get_recommendations_for_playlist(all_recs, user_mapping[pID], inverse_item_mapping)
        elif num_tracks == 1:
            trackID = [track['track_uri'] for track in playlist['tracks']][0]
            temp = get_one_song_cold_start_recs(str(pID), title_one_song_pop_recs, pop_recs, trackID)
        elif num_tracks == 0:
            name = util.normalize_name(playlist['name']).encode('utf-8')
            temp = get_total_cold_start_recs(name, title_pop_recs, pop_recs)

        rec_str = str(playlist['pid'])

        for rec in temp:
            rec_str += ',' + str(rec)
        rec_str += '\n'
        submission_file.write(rec_str)
        submission_file.flush()
    submission_file.close()


if __name__ == '__main__':
    main()
